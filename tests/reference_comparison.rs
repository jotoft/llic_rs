//! Integration tests comparing Rust decompression output against C++ reference.
//!
//! These tests decompress LLIC files using the Rust implementation and compare
//! the output byte-for-byte against reference PGM files generated by the C++ implementation.
//!
//! Run test data generation first: cargo run --bin generate_test_data

use llic::{LlicContext, Quality};
use std::fs;
use std::path::Path;

/// Parse a binary PGM (P5) file and return (width, height, pixel_data)
fn read_pgm(path: &Path) -> Result<(u32, u32, Vec<u8>), String> {
    let data = fs::read(path).map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;

    // Find header end (after "P5\nwidth height\n255\n")
    let mut pos = 0;

    // Skip "P5"
    if data.len() < 3 || &data[0..2] != b"P5" {
        return Err(format!("Not a P5 PGM file: {}", path.display()));
    }
    pos = 2;

    // Skip whitespace
    while pos < data.len() && (data[pos] == b' ' || data[pos] == b'\n' || data[pos] == b'\r') {
        pos += 1;
    }

    // Parse width
    let width_start = pos;
    while pos < data.len() && data[pos].is_ascii_digit() {
        pos += 1;
    }
    let width: u32 = std::str::from_utf8(&data[width_start..pos])
        .map_err(|_| "Invalid width")?
        .parse()
        .map_err(|_| "Invalid width")?;

    // Skip whitespace
    while pos < data.len() && (data[pos] == b' ' || data[pos] == b'\n' || data[pos] == b'\r') {
        pos += 1;
    }

    // Parse height
    let height_start = pos;
    while pos < data.len() && data[pos].is_ascii_digit() {
        pos += 1;
    }
    let height: u32 = std::str::from_utf8(&data[height_start..pos])
        .map_err(|_| "Invalid height")?
        .parse()
        .map_err(|_| "Invalid height")?;

    // Skip whitespace
    while pos < data.len() && (data[pos] == b' ' || data[pos] == b'\n' || data[pos] == b'\r') {
        pos += 1;
    }

    // Parse maxval (should be 255)
    let maxval_start = pos;
    while pos < data.len() && data[pos].is_ascii_digit() {
        pos += 1;
    }
    let maxval: u32 = std::str::from_utf8(&data[maxval_start..pos])
        .map_err(|_| "Invalid maxval")?
        .parse()
        .map_err(|_| "Invalid maxval")?;

    if maxval != 255 {
        return Err(format!("Unsupported maxval {}, expected 255", maxval));
    }

    // Skip single whitespace character after maxval
    pos += 1;

    // Rest is pixel data
    let pixels = data[pos..].to_vec();
    let expected_size = (width * height) as usize;
    if pixels.len() != expected_size {
        return Err(format!(
            "Pixel data size mismatch: got {}, expected {}",
            pixels.len(),
            expected_size
        ));
    }

    Ok((width, height, pixels))
}

/// Parse LLIC container format and return (width, height, compressed_data)
fn read_llic_container(path: &Path) -> Result<(u32, u32, Vec<u8>), String> {
    let data = fs::read(path).map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;

    // Find first newline
    let first_newline = data
        .iter()
        .position(|&b| b == b'\n')
        .ok_or("No newline in LLIC file")?;

    let header_line = std::str::from_utf8(&data[..first_newline]).map_err(|_| "Invalid header")?;

    let parts: Vec<&str> = header_line.split_whitespace().collect();
    if parts.len() != 2 {
        return Err("Invalid header format".to_string());
    }

    let width: u32 = parts[0].parse().map_err(|_| "Invalid width")?;
    let height: u32 = parts[1].parse().map_err(|_| "Invalid height")?;

    // Find second newline
    let second_start = first_newline + 1;
    let second_newline = data[second_start..]
        .iter()
        .position(|&b| b == b'\n')
        .ok_or("No second newline")?
        + second_start;

    let size_line =
        std::str::from_utf8(&data[second_start..second_newline]).map_err(|_| "Invalid size")?;

    let _compressed_size: usize = size_line.trim().parse().map_err(|_| "Invalid size")?;

    // Extract compressed data
    let data_start = second_newline + 1;
    let compressed_data = data[data_start..].to_vec();

    Ok((width, height, compressed_data))
}

/// Test a single pattern at a specific quality level
fn test_pattern(pattern_name: &str, quality: u8) -> Result<(), String> {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let compressed_path =
        Path::new(manifest_dir).join(format!("test_data/compressed/{}_q{}.llic", pattern_name, quality));
    let reference_path =
        Path::new(manifest_dir).join(format!("test_data/reference/{}_q{}.pgm", pattern_name, quality));

    // Skip if files don't exist (test data not generated)
    if !compressed_path.exists() || !reference_path.exists() {
        return Err(format!(
            "Test data not found. Run: cargo run --bin generate_test_data"
        ));
    }

    // Read compressed LLIC file
    let (width, height, compressed_data) = read_llic_container(&compressed_path)?;

    // Read reference PGM
    let (ref_width, ref_height, reference_pixels) = read_pgm(&reference_path)?;

    if width != ref_width || height != ref_height {
        return Err(format!(
            "Dimension mismatch: LLIC {}x{}, reference {}x{}",
            width, height, ref_width, ref_height
        ));
    }

    // Decompress with Rust
    let context = LlicContext::new(width, height, width, Some(1))
        .map_err(|e| format!("Failed to create context: {}", e))?;

    let mut output = vec![0u8; (width * height) as usize];

    let (decoded_quality, _mode) = context
        .decompress_gray8(&compressed_data, &mut output)
        .map_err(|e| format!("Decompression failed: {}", e))?;

    // Verify quality matches
    let expected_quality = match quality {
        0 => Quality::Lossless,
        1 => Quality::VeryHigh,
        2 => Quality::High,
        3 => Quality::Medium,
        4 => Quality::Low,
        _ => return Err(format!("Unknown quality level {}", quality)),
    };

    if decoded_quality != expected_quality {
        return Err(format!(
            "Quality mismatch: expected {:?}, got {:?}",
            expected_quality, decoded_quality
        ));
    }

    // Compare output to reference
    if output != reference_pixels {
        // Find first difference
        for (i, (got, expected)) in output.iter().zip(reference_pixels.iter()).enumerate() {
            if got != expected {
                let x = i % width as usize;
                let y = i / width as usize;
                return Err(format!(
                    "Pixel mismatch at ({}, {}): got {}, expected {}",
                    x, y, got, expected
                ));
            }
        }
        return Err("Output differs from reference (length mismatch)".to_string());
    }

    Ok(())
}

// Generate test functions for all patterns and quality levels
macro_rules! generate_tests {
    ($($name:ident: $pattern:expr, $quality:expr;)*) => {
        $(
            #[test]
            fn $name() {
                if let Err(e) = test_pattern($pattern, $quality) {
                    panic!("{}", e);
                }
            }
        )*
    };
}

// Lossless tests (q0) - these should work with current implementation
generate_tests! {
    // Uniform patterns
    test_uniform_0_8x8_q0: "uniform_0_8x8", 0;
    test_uniform_0_16x16_q0: "uniform_0_16x16", 0;
    test_uniform_0_64x64_q0: "uniform_0_64x64", 0;
    test_uniform_128_8x8_q0: "uniform_128_8x8", 0;
    test_uniform_128_16x16_q0: "uniform_128_16x16", 0;
    test_uniform_128_64x64_q0: "uniform_128_64x64", 0;
    test_uniform_255_8x8_q0: "uniform_255_8x8", 0;
    test_uniform_255_16x16_q0: "uniform_255_16x16", 0;
    test_uniform_255_64x64_q0: "uniform_255_64x64", 0;

    // Gradients
    test_h_gradient_8x8_q0: "h_gradient_8x8", 0;
    test_h_gradient_16x16_q0: "h_gradient_16x16", 0;
    test_h_gradient_64x64_q0: "h_gradient_64x64", 0;
    test_v_gradient_8x8_q0: "v_gradient_8x8", 0;
    test_v_gradient_16x16_q0: "v_gradient_16x16", 0;
    test_v_gradient_64x64_q0: "v_gradient_64x64", 0;
    test_d_gradient_8x8_q0: "d_gradient_8x8", 0;
    test_d_gradient_16x16_q0: "d_gradient_16x16", 0;
    test_d_gradient_64x64_q0: "d_gradient_64x64", 0;

    // Checkerboard
    test_checker_1_16x16_q0: "checker_1_16x16", 0;
    test_checker_1_64x64_q0: "checker_1_64x64", 0;
    test_checker_2_16x16_q0: "checker_2_16x16", 0;
    test_checker_2_64x64_q0: "checker_2_64x64", 0;
    test_checker_4_16x16_q0: "checker_4_16x16", 0;
    test_checker_4_64x64_q0: "checker_4_64x64", 0;
    test_checker_8_16x16_q0: "checker_8_16x16", 0;
    test_checker_8_64x64_q0: "checker_8_64x64", 0;

    // Noise
    test_noise_16x16_q0: "noise_16x16", 0;
    test_noise_64x64_q0: "noise_64x64", 0;

    // Smooth
    test_smooth_16x16_q0: "smooth_16x16", 0;
    test_smooth_64x64_q0: "smooth_64x64", 0;

    // Stripes
    test_stripes_16x16_q0: "stripes_16x16", 0;
    test_stripes_64x64_q0: "stripes_64x64", 0;

    // Circle
    test_circle_16x16_q0: "circle_16x16", 0;
    test_circle_64x64_q0: "circle_64x64", 0;

    // Radial
    test_radial_16x16_q0: "radial_16x16", 0;
    test_radial_64x64_q0: "radial_64x64", 0;
}

// Lossy tests (q1-q4)
generate_tests! {
    // VeryHigh quality (q1)
    test_uniform_128_64x64_q1: "uniform_128_64x64", 1;
    test_h_gradient_64x64_q1: "h_gradient_64x64", 1;
    test_noise_64x64_q1: "noise_64x64", 1;

    // High quality (q2)
    test_uniform_128_64x64_q2: "uniform_128_64x64", 2;
    test_h_gradient_64x64_q2: "h_gradient_64x64", 2;
    test_noise_64x64_q2: "noise_64x64", 2;

    // Medium quality (q3)
    test_uniform_128_64x64_q3: "uniform_128_64x64", 3;
    test_h_gradient_64x64_q3: "h_gradient_64x64", 3;
    test_noise_64x64_q3: "noise_64x64", 3;

    // Low quality (q4)
    test_uniform_128_64x64_q4: "uniform_128_64x64", 4;
    test_h_gradient_64x64_q4: "h_gradient_64x64", 4;
    test_noise_64x64_q4: "noise_64x64", 4;
}
