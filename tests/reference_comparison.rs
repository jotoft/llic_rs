//! Integration tests comparing Rust decompression output against C++ reference.
//!
//! These tests decompress LLIC files using the Rust implementation and compare
//! the output byte-for-byte against reference PGM files generated by the C++ implementation.
//!
//! Run test data generation first: cargo run --bin generate_test_data

use llic::{LlicContext, Quality};
use std::fs;
use std::path::Path;

/// Parse a binary PGM (P5) file and return (width, height, pixel_data)
fn read_pgm(path: &Path) -> Result<(u32, u32, Vec<u8>), String> {
    let data = fs::read(path).map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;

    // Find header end (after "P5\nwidth height\n255\n")
    let mut pos = 0;

    // Skip "P5"
    if data.len() < 3 || &data[0..2] != b"P5" {
        return Err(format!("Not a P5 PGM file: {}", path.display()));
    }
    pos = 2;

    // Skip whitespace
    while pos < data.len() && (data[pos] == b' ' || data[pos] == b'\n' || data[pos] == b'\r') {
        pos += 1;
    }

    // Parse width
    let width_start = pos;
    while pos < data.len() && data[pos].is_ascii_digit() {
        pos += 1;
    }
    let width: u32 = std::str::from_utf8(&data[width_start..pos])
        .map_err(|_| "Invalid width")?
        .parse()
        .map_err(|_| "Invalid width")?;

    // Skip whitespace
    while pos < data.len() && (data[pos] == b' ' || data[pos] == b'\n' || data[pos] == b'\r') {
        pos += 1;
    }

    // Parse height
    let height_start = pos;
    while pos < data.len() && data[pos].is_ascii_digit() {
        pos += 1;
    }
    let height: u32 = std::str::from_utf8(&data[height_start..pos])
        .map_err(|_| "Invalid height")?
        .parse()
        .map_err(|_| "Invalid height")?;

    // Skip whitespace
    while pos < data.len() && (data[pos] == b' ' || data[pos] == b'\n' || data[pos] == b'\r') {
        pos += 1;
    }

    // Parse maxval (should be 255)
    let maxval_start = pos;
    while pos < data.len() && data[pos].is_ascii_digit() {
        pos += 1;
    }
    let maxval: u32 = std::str::from_utf8(&data[maxval_start..pos])
        .map_err(|_| "Invalid maxval")?
        .parse()
        .map_err(|_| "Invalid maxval")?;

    if maxval != 255 {
        return Err(format!("Unsupported maxval {}, expected 255", maxval));
    }

    // Skip single whitespace character after maxval
    pos += 1;

    // Rest is pixel data
    let pixels = data[pos..].to_vec();
    let expected_size = (width * height) as usize;
    if pixels.len() != expected_size {
        return Err(format!(
            "Pixel data size mismatch: got {}, expected {}",
            pixels.len(),
            expected_size
        ));
    }

    Ok((width, height, pixels))
}

/// Parse LLIC container format and return (width, height, compressed_data)
fn read_llic_container(path: &Path) -> Result<(u32, u32, Vec<u8>), String> {
    let data = fs::read(path).map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;

    // Find first newline
    let first_newline = data
        .iter()
        .position(|&b| b == b'\n')
        .ok_or("No newline in LLIC file")?;

    let header_line = std::str::from_utf8(&data[..first_newline]).map_err(|_| "Invalid header")?;

    let parts: Vec<&str> = header_line.split_whitespace().collect();
    if parts.len() != 2 {
        return Err("Invalid header format".to_string());
    }

    let width: u32 = parts[0].parse().map_err(|_| "Invalid width")?;
    let height: u32 = parts[1].parse().map_err(|_| "Invalid height")?;

    // Find second newline
    let second_start = first_newline + 1;
    let second_newline = data[second_start..]
        .iter()
        .position(|&b| b == b'\n')
        .ok_or("No second newline")?
        + second_start;

    let size_line =
        std::str::from_utf8(&data[second_start..second_newline]).map_err(|_| "Invalid size")?;

    let _compressed_size: usize = size_line.trim().parse().map_err(|_| "Invalid size")?;

    // Extract compressed data
    let data_start = second_newline + 1;
    let compressed_data = data[data_start..].to_vec();

    Ok((width, height, compressed_data))
}

/// Test a single pattern at a specific quality level
fn test_pattern(pattern_name: &str, quality: u8) -> Result<(), String> {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let compressed_path =
        Path::new(manifest_dir).join(format!("test_data/compressed/{}_q{}.llic", pattern_name, quality));
    let reference_path =
        Path::new(manifest_dir).join(format!("test_data/reference/{}_q{}.pgm", pattern_name, quality));

    // Skip if files don't exist (test data not generated)
    if !compressed_path.exists() || !reference_path.exists() {
        return Err(format!(
            "Test data not found. Run: cargo run --bin generate_test_data"
        ));
    }

    // Read compressed LLIC file
    let (width, height, compressed_data) = read_llic_container(&compressed_path)?;

    // Read reference PGM
    let (ref_width, ref_height, reference_pixels) = read_pgm(&reference_path)?;

    if width != ref_width || height != ref_height {
        return Err(format!(
            "Dimension mismatch: LLIC {}x{}, reference {}x{}",
            width, height, ref_width, ref_height
        ));
    }

    // Decompress with Rust
    let context = LlicContext::new(width, height, width, Some(1))
        .map_err(|e| format!("Failed to create context: {}", e))?;

    let mut output = vec![0u8; (width * height) as usize];

    let (decoded_quality, _mode) = context
        .decompress_gray8(&compressed_data, &mut output)
        .map_err(|e| format!("Decompression failed: {}", e))?;

    // Verify quality matches
    let expected_quality = match quality {
        0 => Quality::Lossless,
        1 => Quality::VeryHigh,
        2 => Quality::High,
        3 => Quality::Medium,
        4 => Quality::Low,
        _ => return Err(format!("Unknown quality level {}", quality)),
    };

    if decoded_quality != expected_quality {
        return Err(format!(
            "Quality mismatch: expected {:?}, got {:?}",
            expected_quality, decoded_quality
        ));
    }

    // Compare output to reference
    if output != reference_pixels {
        // Find first difference
        for (i, (got, expected)) in output.iter().zip(reference_pixels.iter()).enumerate() {
            if got != expected {
                let x = i % width as usize;
                let y = i / width as usize;
                return Err(format!(
                    "Pixel mismatch at ({}, {}): got {}, expected {}",
                    x, y, got, expected
                ));
            }
        }
        return Err("Output differs from reference (length mismatch)".to_string());
    }

    Ok(())
}

// Generate test functions for all patterns and quality levels
macro_rules! generate_tests {
    ($($name:ident: $pattern:expr, $quality:expr;)*) => {
        $(
            #[test]
            fn $name() {
                if let Err(e) = test_pattern($pattern, $quality) {
                    panic!("{}", e);
                }
            }
        )*
    };
}

// Lossless tests (q0) - these should work with current implementation
generate_tests! {
    // Uniform patterns
    test_uniform_0_8x8_q0: "uniform_0_8x8", 0;
    test_uniform_0_16x16_q0: "uniform_0_16x16", 0;
    test_uniform_0_64x64_q0: "uniform_0_64x64", 0;
    test_uniform_128_8x8_q0: "uniform_128_8x8", 0;
    test_uniform_128_16x16_q0: "uniform_128_16x16", 0;
    test_uniform_128_64x64_q0: "uniform_128_64x64", 0;
    test_uniform_255_8x8_q0: "uniform_255_8x8", 0;
    test_uniform_255_16x16_q0: "uniform_255_16x16", 0;
    test_uniform_255_64x64_q0: "uniform_255_64x64", 0;

    // Gradients
    test_h_gradient_8x8_q0: "h_gradient_8x8", 0;
    test_h_gradient_16x16_q0: "h_gradient_16x16", 0;
    test_h_gradient_64x64_q0: "h_gradient_64x64", 0;
    test_v_gradient_8x8_q0: "v_gradient_8x8", 0;
    test_v_gradient_16x16_q0: "v_gradient_16x16", 0;
    test_v_gradient_64x64_q0: "v_gradient_64x64", 0;
    test_d_gradient_8x8_q0: "d_gradient_8x8", 0;
    test_d_gradient_16x16_q0: "d_gradient_16x16", 0;
    test_d_gradient_64x64_q0: "d_gradient_64x64", 0;

    // Checkerboard
    test_checker_1_16x16_q0: "checker_1_16x16", 0;
    test_checker_1_64x64_q0: "checker_1_64x64", 0;
    test_checker_2_16x16_q0: "checker_2_16x16", 0;
    test_checker_2_64x64_q0: "checker_2_64x64", 0;
    test_checker_4_16x16_q0: "checker_4_16x16", 0;
    test_checker_4_64x64_q0: "checker_4_64x64", 0;
    test_checker_8_16x16_q0: "checker_8_16x16", 0;
    test_checker_8_64x64_q0: "checker_8_64x64", 0;

    // Noise
    test_noise_16x16_q0: "noise_16x16", 0;
    test_noise_64x64_q0: "noise_64x64", 0;

    // Smooth
    test_smooth_16x16_q0: "smooth_16x16", 0;
    test_smooth_64x64_q0: "smooth_64x64", 0;

    // Stripes
    test_stripes_16x16_q0: "stripes_16x16", 0;
    test_stripes_64x64_q0: "stripes_64x64", 0;

    // Circle
    test_circle_16x16_q0: "circle_16x16", 0;
    test_circle_64x64_q0: "circle_64x64", 0;

    // Radial
    test_radial_16x16_q0: "radial_16x16", 0;
    test_radial_64x64_q0: "radial_64x64", 0;
}

// Lossy tests (q1-q4)
generate_tests! {
    // VeryHigh quality (q1)
    test_uniform_128_64x64_q1: "uniform_128_64x64", 1;
    test_h_gradient_64x64_q1: "h_gradient_64x64", 1;
    test_noise_64x64_q1: "noise_64x64", 1;

    // High quality (q2)
    test_uniform_128_64x64_q2: "uniform_128_64x64", 2;
    test_h_gradient_64x64_q2: "h_gradient_64x64", 2;
    test_noise_64x64_q2: "noise_64x64", 2;

    // Medium quality (q3)
    test_uniform_128_64x64_q3: "uniform_128_64x64", 3;
    test_h_gradient_64x64_q3: "h_gradient_64x64", 3;
    test_noise_64x64_q3: "noise_64x64", 3;

    // Low quality (q4)
    test_uniform_128_64x64_q4: "uniform_128_64x64", 4;
    test_h_gradient_64x64_q4: "h_gradient_64x64", 4;
    test_noise_64x64_q4: "noise_64x64", 4;
}

// =============================================================================
// Compression comparison tests: compare Rust lossy compression with C++ output
// =============================================================================

/// Test that Rust lossy compression produces output that can be correctly decompressed
/// and matches what C++ produces (when decompressed).
#[test]
fn test_lossy_compression_roundtrip() {
    use llic::{Mode, Quality};

    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let pgm_path = Path::new(manifest_dir).join("test_data/checkerboard_16x16.pgm");

    if !pgm_path.exists() {
        eprintln!("Test PGM not found: {:?}", pgm_path);
        return;
    }

    // Read test image
    let (width, height, pixels) = read_pgm(&pgm_path).expect("Failed to read PGM");

    // Test each lossy quality level
    for (quality, error_limit) in [
        (Quality::VeryHigh, 2),
        (Quality::High, 4),
        (Quality::Medium, 8),
        (Quality::Low, 16),
    ] {
        // Compress with Rust
        let context = LlicContext::new(width, height, width, Some(1))
            .expect("Failed to create context");

        let mut compressed = vec![0u8; context.compressed_buffer_size()];
        let compressed_size = context
            .compress_gray8(&pixels, quality, Mode::Fast, &mut compressed)
            .expect("Compression failed");
        compressed.truncate(compressed_size);

        // Decompress
        let mut decompressed = vec![0u8; (width * height) as usize];
        let (decoded_quality, _mode) = context
            .decompress_gray8(&compressed, &mut decompressed)
            .expect("Decompression failed");

        assert_eq!(
            decoded_quality, quality,
            "Quality mismatch for error_limit {}",
            error_limit
        );

        // Verify all pixels are within error bounds
        for i in 0..pixels.len() {
            let diff = (pixels[i] as i32 - decompressed[i] as i32).abs();
            assert!(
                diff <= error_limit + 1, // +1 for bucket centering
                "Pixel {} error {} exceeds limit {} (quality {:?}): original={}, decompressed={}",
                i,
                diff,
                error_limit,
                quality,
                pixels[i],
                decompressed[i]
            );
        }
    }
}

/// Test that Rust compression output format matches C++ output format byte-for-byte
/// when both use the same input and settings.
#[test]
fn test_lossy_compression_format_match() {
    use llic::{Mode, Quality};
    use std::process::Command;

    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let pgm_path = Path::new(manifest_dir).join("test_data/checkerboard_16x16.pgm");
    let cpp_tool = Path::new(manifest_dir).join("llic/build/src/llic_compress/llic_compress");

    if !pgm_path.exists() {
        eprintln!("Test PGM not found: {:?}", pgm_path);
        return;
    }

    if !cpp_tool.exists() {
        eprintln!("C++ tool not found: {:?}. Run: cd llic/build && make llic_compress", cpp_tool);
        return;
    }

    // Read test image
    let (width, height, pixels) = read_pgm(&pgm_path).expect("Failed to read PGM");

    // Test quality level: High (error_limit=4)
    // C++ tool uses quality 0-4: 0=lossless, 1=very_high(2), 2=high(4), 3=medium(8), 4=low(16)
    let quality = Quality::High;
    let error_limit = 4;
    let cpp_quality_level = 2; // Corresponds to Quality::High

    // Compress with Rust
    let context = LlicContext::new(width, height, width, Some(1))
        .expect("Failed to create context");

    let mut rust_compressed = vec![0u8; context.compressed_buffer_size()];
    let rust_size = context
        .compress_gray8(&pixels, quality, Mode::Fast, &mut rust_compressed)
        .expect("Rust compression failed");
    rust_compressed.truncate(rust_size);

    // Compress with C++
    let cpp_output_path = std::env::temp_dir().join("test_cpp_compress.llic");
    let output = Command::new(&cpp_tool)
        .args([
            "c",
            pgm_path.to_str().unwrap(),
            cpp_output_path.to_str().unwrap(),
            &cpp_quality_level.to_string(),
            "fast",
        ])
        .output()
        .expect("Failed to run C++ tool");

    if !output.status.success() {
        eprintln!("C++ tool failed: {}", String::from_utf8_lossy(&output.stderr));
        return;
    }

    // Read C++ output (skip container header)
    let cpp_data = fs::read(&cpp_output_path).expect("Failed to read C++ output");
    let (cpp_width, cpp_height, cpp_compressed) =
        read_llic_container(&cpp_output_path).expect("Failed to parse C++ output");

    assert_eq!(cpp_width, width);
    assert_eq!(cpp_height, height);

    // Compare the raw block data (skip LLIC v3 header from Rust output)
    // Rust header: version(1) + num_blocks(1) + block_size(4) = 6 bytes
    // C++ container adds text header, but read_llic_container extracts just the binary part
    // which includes version(1) + num_blocks(1) + 16 block_sizes(64) + block data

    // For single-threaded Rust: header is [version=3, num_blocks=1, block_size(4 bytes), block_data...]
    // For C++ with 16 threads: header is [version=3, num_blocks=16, block_sizes(16*4), block_data...]

    // The block data format should match - let's extract and compare the first block
    let rust_block_data = &rust_compressed[6..]; // Skip version(1) + num_blocks(1) + size(4)

    // C++ uses 16 blocks, find the block with the actual data
    let cpp_num_blocks = cpp_compressed[1] as usize;
    let mut cpp_block_sizes = Vec::new();
    let mut pos = 2;
    for _ in 0..cpp_num_blocks {
        let size = u32::from_le_bytes([
            cpp_compressed[pos],
            cpp_compressed[pos + 1],
            cpp_compressed[pos + 2],
            cpp_compressed[pos + 3],
        ]);
        cpp_block_sizes.push(size);
        pos += 4;
    }

    // Find first non-zero block
    let first_block_idx = cpp_block_sizes.iter().position(|&s| s > 0).unwrap_or(0);
    let cpp_block_start = pos + cpp_block_sizes[..first_block_idx].iter().map(|&s| s as usize).sum::<usize>();
    let cpp_block_size = cpp_block_sizes[first_block_idx] as usize;
    let cpp_block_data = &cpp_compressed[cpp_block_start..cpp_block_start + cpp_block_size];

    // Compare header bytes (error_limit)
    assert_eq!(
        rust_block_data[0] & 0x7f,
        cpp_block_data[0] & 0x7f,
        "Error limit mismatch: Rust={}, C++={}",
        rust_block_data[0] & 0x7f,
        cpp_block_data[0] & 0x7f
    );

    // Both should have uncompressed headers (bit 7 = 0)
    assert_eq!(
        rust_block_data[0] & 0x80,
        0,
        "Rust should use uncompressed header"
    );
    assert_eq!(
        cpp_block_data[0] & 0x80,
        0,
        "C++ should use uncompressed header in fast mode"
    );

    // Verify both decompress to same result
    let mut rust_decompressed = vec![0u8; (width * height) as usize];
    context
        .decompress_gray8(&rust_compressed, &mut rust_decompressed)
        .expect("Rust decompression failed");

    let mut cpp_decompressed = vec![0u8; (width * height) as usize];
    context
        .decompress_gray8(&cpp_compressed, &mut cpp_decompressed)
        .expect("C++ decompression failed");

    // Both should produce similar results (may differ due to block assignment with threading)
    for i in 0..pixels.len() {
        let rust_diff = (pixels[i] as i32 - rust_decompressed[i] as i32).abs();
        let cpp_diff = (pixels[i] as i32 - cpp_decompressed[i] as i32).abs();

        assert!(
            rust_diff <= error_limit + 1,
            "Rust pixel {} error {} exceeds limit {}",
            i, rust_diff, error_limit
        );
        assert!(
            cpp_diff <= error_limit + 1,
            "C++ pixel {} error {} exceeds limit {}",
            i, cpp_diff, error_limit
        );
    }

    // Clean up
    let _ = fs::remove_file(&cpp_output_path);
}
